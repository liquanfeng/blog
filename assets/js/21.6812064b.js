(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{261:function(v,t,_){"use strict";_.r(t);var e=_(5),l=Object(e.a)({},(function(){var v=this,t=v.$createElement,_=v._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"目标文件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#目标文件"}},[v._v("#")]),v._v(" 目标文件")]),v._v(" "),_("center",[v._v("数据段")]),v._v(" "),_("center",[v._v("代码段")]),v._v(" "),_("center",[v._v("符号表")]),v._v(" "),_("p",[v._v("全局变量在数据段，函数体包括其中的局部变量在代码段")]),v._v(" "),_("h2",{attrs:{id:"链接过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#链接过程"}},[v._v("#")]),v._v(" 链接过程")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("符号决议"),_("br"),v._v("\n符号表中保存的信息有两部分：")]),v._v(" "),_("ul",[_("li",[v._v("目标文件中引用的全局变量以及函数，需要其它文件提供使用的符号")]),v._v(" "),_("li",[v._v("目标文件中定义的全局变量以及函数，提供给其它文件使用的符号")])]),v._v(" "),_("p",[v._v("链接过程中进行符号决议，失败出现符号重定义和未定义")])]),v._v(" "),_("li",[_("p",[v._v("重定位")]),v._v(" "),_("ol",[_("li",[v._v("合并目标文件之间的同类型段并重定位"),_("br"),v._v("\n相对地址是编译器在编译过程中确定，在链接器完成后被链接器修正为最终地址")]),v._v(" "),_("li",[v._v("引用符号重定位"),_("br"),v._v("\n编译器没有确定的所引用的外部函数以及变量的地址设置为空(0x000000)，并分别将该信息记录在了目标文件的.rel.text以及.rel.data段中。"),_("br"),v._v("\n在这个阶段链接器依次扫描所有的.rel.text以及.rel.data段并找到相应变量的最终地址，并将机器指令中的0x000000修正为所引用变量的最终地址")])])])]),v._v(" "),_("h2",{attrs:{id:"静态链接和动态链接"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#静态链接和动态链接"}},[v._v("#")]),v._v(" 静态链接和动态链接")]),v._v(" "),_("h3",{attrs:{id:"静态链接"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#静态链接"}},[v._v("#")]),v._v(" 静态链接")]),v._v(" "),_("p",[v._v("链接时直接把库装进可执行文件，相同段合并"),_("br"),v._v("\n可执行文件和目标文件没有什么本质的不同，区别在于可执行文件有一个供OS调用的入口函数")]),v._v(" "),_("h3",{attrs:{id:"动态链接-dll-so"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#动态链接-dll-so"}},[v._v("#")]),v._v(" 动态链接(.dll/.so)")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("加载时链接"),_("br"),v._v("\n可执行文件从磁盘拷到内存时，且在程序开始运行之前，OS查找可执行文件依赖的动态库信息(主要是动态库的名字以及存放路径)，找到该动态库后就将该动态库从磁盘搬到内存，并进行符号决议")])]),v._v(" "),_("li",[_("p",[v._v("运行时链接"),_("br"),v._v("\n执行时打开库文件，linux下比如"),_("code",[v._v("dlopen()")]),v._v("，windows下比如"),_("code",[v._v("LoadLibrary")])])]),v._v(" "),_("li",[_("p",[v._v("dynamic和GOT"),_("br"),v._v("\n可执行文件较静态链接多出两段dynamic和GOT(Global Offset Table)\n"),_("center",[v._v("数据段")]),v._v(" "),_("center",[v._v("代码段")]),v._v(" "),_("center",[v._v("符号表")]),v._v(" "),_("center",[v._v(".dynamic")]),v._v(" "),_("center",[v._v("GOT")])],1),v._v(" "),_("ul",[_("li",[v._v(".dynamic段中保存了可执行文件依赖哪些动态库，动态链接符号表的位置以及重定位表的位置等信息")]),v._v(" "),_("li",[v._v("GOT(.got，.got.plt)，全局偏移量表，存放所有全局变量指针(.got保存全局变量引用的地址，.got.plt保存函数引用的地址)\n对于模块外部引用的全局变量和全局函数，用GOT表的表项内容作为地址来间接寻址"),_("br"),v._v("\n对于本模块内的静态变量和静态函数，用GOT表的首地址作为一个基准，用相对于该基准的偏移量来引用")])])])]),v._v(" "),_("h3",{attrs:{id:"静态链接vs动态链接"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#静态链接vs动态链接"}},[v._v("#")]),v._v(" 静态链接vs动态链接")]),v._v(" "),_("ul",[_("li",[v._v("优点可以独立执行没有依赖问题")]),v._v(" "),_("li",[v._v("动态链接优点节省空间，热更新，多语言编程。缺点在于执行会静态稍慢，而且没有库就不能独立执行")])]),v._v(" "),_("h2",{attrs:{id:"可执行文件加载执行过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#可执行文件加载执行过程"}},[v._v("#")]),v._v(" 可执行文件加载执行过程")]),v._v(" "),_("ol",[_("li",[v._v("在shell命令行提示符后输入命令：$./hello")]),v._v(" "),_("li",[v._v("shell命令行解释器构造argv和envp")]),v._v(" "),_("li",[v._v("调用fork()函数，创建一个子进程，与父进程shell完全相同（只读/共享），包括只读代码段、可读写数据段、堆以及用户栈等。")]),v._v(" "),_("li",[v._v("调用execve()函数,在当前进程（新创建的子进程）的上下文中加载并运行hello程序。将hello中的.text节、.data节、.bss节等内容加载到当前进程的虚拟地址空间（仅修改当前进程上下文中关于存储映像的一些数据结构，不从磁盘拷贝代码、数据等内容）")]),v._v(" "),_("li",[v._v("调用hello程序的main()函数，hello程序开始在一个进程的上下文中运行。")])]),v._v(" "),_("blockquote",[_("p",[v._v("码农的荒岛求生：彻底理解链接器"),_("br"),v._v("\nhttps://blog.csdn.net/joker0910/article/details/7684902"),_("br"),v._v("\nhttps://www.anquanke.com/post/id/183370")])])],1)}),[],!1,null,null,null);t.default=l.exports}}]);