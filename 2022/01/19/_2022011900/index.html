<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>卷积神经网络 | liquanfeng&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css">
    <meta name="description" content="
对于图像数据直接用全连接，参数过于庞大

假设你想从⼀张图⽚中找到某个物体。合理的假设是：⽆论哪种⽅法找到这个物体，都应该和物体的位置⽆关。

卷积神经⽹络正是将空间不变性（spatial invariance）
的这⼀概念系统化，从而基于这个模型使⽤较少的参数来学习有⽤的表⽰。
平移不变性（translation invariance）：不管检测对象出现在图像中的哪个位置，神经⽹络的前⾯ ...">
    
    <link rel="preload" href="/assets/css/0.styles.dfc854de.css" as="style"><link rel="preload" href="/assets/js/app.7d39d6e2.js" as="script"><link rel="preload" href="/assets/js/8.a1e5b26c.js" as="script"><link rel="preload" href="/assets/js/3.ebaad69b.js" as="script"><link rel="preload" href="/assets/js/5.5b02d5fc.js" as="script"><link rel="prefetch" href="/assets/js/10.36b1f5e2.js"><link rel="prefetch" href="/assets/js/11.91986586.js"><link rel="prefetch" href="/assets/js/12.177629a3.js"><link rel="prefetch" href="/assets/js/13.75be565a.js"><link rel="prefetch" href="/assets/js/14.b0129c35.js"><link rel="prefetch" href="/assets/js/15.ec43e66c.js"><link rel="prefetch" href="/assets/js/16.a6f8e4c1.js"><link rel="prefetch" href="/assets/js/17.2545800b.js"><link rel="prefetch" href="/assets/js/18.d30fbabd.js"><link rel="prefetch" href="/assets/js/19.99985f98.js"><link rel="prefetch" href="/assets/js/20.7bac50d7.js"><link rel="prefetch" href="/assets/js/21.6812064b.js"><link rel="prefetch" href="/assets/js/4.0d72ee38.js"><link rel="prefetch" href="/assets/js/6.4ae5a2b5.js"><link rel="prefetch" href="/assets/js/7.92b3fa39.js"><link rel="prefetch" href="/assets/js/9.69cc970a.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.432adde3.js">
    <link rel="stylesheet" href="/assets/css/0.styles.dfc854de.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/" class="nav-link home-link">liquanfeng's blog </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/" class="nav-link">Blog</a></li><li class="nav-item"><a href="/tag/" class="nav-link">Tags</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/" class="nav-link mobile-home-link">liquanfeng's blog </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/" class="nav-link">Blog</a></li><li class="mobile-nav-item"><a href="/tag/" class="nav-link">Tags</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        卷积神经网络
      </h1> <div class="post-meta"><div itemprop="publisher author" itemtype="http://schema.org/Person" itemscope="itemscope" class="post-meta-author"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-navigation"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg> <span itemprop="name">liquanfeng</span> <span itemprop="address">   in Beijing</span></div> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2022-01-19T00:00:00.000Z">
      Wed Jan 19 2022
    </time></div> <ul itemprop="keywords" class="post-meta-tags"><li class="post-tag" data-v-42ccfcd5><a href="/tag/AI" data-v-42ccfcd5><span data-v-42ccfcd5>AI</span></a></li></ul></div></header> <div itemprop="articleBody" class="content__default"><h2 id="从全连接到卷积"><a href="#从全连接到卷积" class="header-anchor">#</a> 从全连接到卷积</h2> <p>对于图像数据直接用全连接，参数过于庞大</p> <p>假设你想从⼀张图⽚中找到某个物体。合理的假设是：⽆论哪种⽅法找到这个物体，都应该和物体的位置⽆关。</p> <p>卷积神经⽹络正是将空间不变性（spatial invariance）
的这⼀概念系统化，从而基于这个模型使⽤较少的参数来学习有⽤的表⽰。</p> <ol><li>平移不变性（translation invariance）：不管检测对象出现在图像中的哪个位置，神经⽹络的前⾯⼏层应该对相同的图像区域具有相似的反应，即为“平移不变性”。</li> <li>局部性（locality）：神经⽹络的前⾯⼏层应该只探索输⼊图像中的局部区域，而不过度在意图像中相隔较远区域的关系，这就是“局部性”原则。最终，在后续神经⽹络，整个图像级别上可以集成这些局部特征⽤于预测。</li></ol> <ul><li>图像的平移不变性使我们以相同的⽅式处理局部图像，而不在乎它的位置。</li> <li>局部性意味着计算相应的隐藏表⽰只需⼀小部分局部图像像素。</li> <li>在图像处理中，卷积层通常⽐全连接层需要更少的参数，但依旧获得⾼效⽤的模型。</li></ul> <h2 id="卷积层"><a href="#卷积层" class="header-anchor">#</a> 卷积层</h2> <h3 id="填充"><a href="#填充" class="header-anchor">#</a> 填充</h3> <p>解决像素丢失的问题</p> <p>卷积神经⽹络中卷积核的⾼度和宽度通常为奇数，例如1、3、5或7。选择奇数的好处是，保持空间维度的同时，我们可以在顶部和底部填充相同数量的⾏，在左侧和右侧填充相同数量的列。此外，使⽤奇数核和填充也提供了书写上的便利。对于任何⼆维张量X，当满⾜：</p> <ol><li>内核的⼤小是奇数
2.所有边的填充⾏数和列数相同</li> <li>输出与输⼊具有相同⾼度和宽度</li></ol> <p>则可以得出：输出Y[i, j]是通过以输
⼊X[i, j]为中⼼，与卷积核进⾏互相关计算得到的。</p> <ul><li>填充可以增加输出的⾼度和宽度。这常⽤来使输出与输⼊具有相同的⾼和宽。</li> <li>步幅可以减小输出的⾼和宽。</li></ul> <h2 id="多输入多输出通道"><a href="#多输入多输出通道" class="header-anchor">#</a> 多输⼊多输出通道</h2> <h3 id="多输入通道"><a href="#多输入通道" class="header-anchor">#</a> 多输入通道</h3> <center><p><img src="/assets/img/conv-multi-in.08d2b40e.svg" alt="img lost"></p></center> <h3 id="多输出通道"><a href="#多输出通道" class="header-anchor">#</a> 多输出通道</h3> <p>随着神经⽹络层数的加深，我们常会增加输出通道的维数，通过减少空间分辨率以获得更⼤的通道深度。</p> <p>⽤<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">c</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>o</mi></msub></mrow><annotation encoding="application/x-tex">c_o</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">c</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">o</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>分别表⽰输⼊和输出通道的数⽬，并让<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mi>h</mi></msub></mrow><annotation encoding="application/x-tex">k_h</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03148em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">h</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">k_w</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03148em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.02691em;">w</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>为卷积核的⾼度和宽度。为了获得多个通道的输出，我们可以为每个输出通道创建⼀个形状为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub><mo>×</mo><msub><mi>k</mi><mi>h</mi></msub><mo>×</mo><msub><mi>k</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">c_i \times k_h \times k_w</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">c</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">×</span><span class="mord"><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03148em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">h</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">×</span><span class="mord"><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03148em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.02691em;">w</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>的卷积核张量，这样卷积核的形状是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>o</mi></msub><mo>×</mo><msub><mi>c</mi><mi>i</mi></msub><mo>×</mo><msub><mi>k</mi><mi>h</mi></msub><mo>×</mo><msub><mi>k</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">c_o \times c_i \times k_h \times k_w</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">c</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">o</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">×</span><span class="mord"><span class="mord mathit">c</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">×</span><span class="mord"><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03148em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">h</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">×</span><span class="mord"><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03148em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.02691em;">w</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>。在互相关运算中，每个输出通道先获取所有输⼊通道，再以对应该输出通道的卷积核计算出结果。</p> <h3 id="_1x1卷积层"><a href="#_1x1卷积层" class="header-anchor">#</a> 1X1卷积层</h3> <p>实1X1卷积的唯⼀计算发⽣在通道上。</p> <center><p><img src="/assets/img/conv-1x1.e980170e.svg" alt="img lost"></p> <p>互相关计算使⽤有3个输⼊通道和2个输出通道的1×1卷积核。输⼊和输出有相同的⾼度和宽度</p></center> <ul><li>多输⼊多输出通道可以⽤来扩展卷积层的模型。</li> <li>当以每像素为基础应⽤时，1x1卷积层相当于全连接层。</li> <li>1X1卷积层通常⽤于调整⽹络层的通道数量和控制模型复杂性。</li></ul> <h2 id="汇聚层-pooling"><a href="#汇聚层-pooling" class="header-anchor">#</a> 汇聚层 Pooling</h2> <p>有双重⽬的：降低卷积层对位置的敏感性，同时降低对空间降采样表⽰
的敏感性。</p> <p>在处理多通道输⼊数据时，汇聚层在每个输⼊通道上单独运算，而不是像卷积层⼀样在通道上对输⼊进⾏汇总。这意味着汇聚层的输出通道数与输⼊通道数相同。</p> <ul><li>汇聚层的主要优点之⼀是减轻卷积层对位置的过度敏感。</li> <li>使⽤最⼤汇聚层以及⼤于1的步幅，可减少空间维度（如⾼度和宽度）。</li> <li>汇聚层的输出通道数与输⼊通道数相同。</li></ul> <h2 id="lenet"><a href="#lenet" class="header-anchor">#</a> LeNet</h2> <p>LeNet（LeNet-5）由两个部分组成：</p> <ul><li>卷积编码器：由两个卷积层组成。</li> <li>全连接层密集块：由三个全连接层组成。</li></ul> <center><p><img src="/assets/img/lenet-vert.4a5d858e.svg" alt="img lost"></p></center> <ul><li>卷积神经⽹络（CNN）是⼀类使⽤卷积层的⽹络。</li> <li>在卷积神经⽹络中，我们组合使⽤卷积层、⾮线性激活函数和汇聚层。</li> <li>为了构造⾼性能的卷积神经⽹络，我们通常对卷积层进⾏排列，逐渐降低其表⽰的空间分辨率，同时增
加通道数。</li> <li>在传统的卷积神经⽹络中，卷积块编码得到的表征在输出之前需由⼀个或多个全连接层进⾏处理。</li></ul> <h2 id="alexnet"><a href="#alexnet" class="header-anchor">#</a> AlexNet</h2> <p>第⼀个在⼤规模视觉竞赛中击败传统计算机视觉模型的⼤型神经⽹络。</p> <p>⾸先，AlexNet⽐相对较小的LeNet5要深得多。AlexNet由⼋层组成：五个卷积层、两个全连接隐藏层和⼀个全连接输出层。其次，AlexNet使⽤ReLU而不是sigmoid作为其激活函数。</p> <center><p><img src="/assets/img/alexnet.66e0f2ea.svg" alt="img lost"></p> <p>从LeNet（左）到AlexNet（右）</p></center> <ul><li>AlexNet的架构与LeNet相似，但使⽤了更多的卷积层和更多的参数来拟合⼤规模的ImageNet数据集。</li> <li>今天，AlexNet已经被更有效的架构所超越，但它是从浅层⽹络到深层⽹络的关键⼀步。</li> <li>尽管AlexNet的代码只⽐LeNet多出⼏⾏，但学术界花了很多年才接受深度学习这⼀概念，并应⽤其出⾊的实验结果。这也是由于缺乏有效的计算⼯具。</li> <li>Dropout、ReLU和预处理是提升计算机视觉任务性能的其他关键步骤。</li></ul> <h2 id="vgg"><a href="#vgg" class="header-anchor">#</a> VGG</h2> <p>VGG利⽤许多重复的神经⽹络块。</p> <p>经典卷积神经⽹络的基本组成部分是下⾯的这个序列：</p> <ol><li>带填充以保持分辨率的卷积层；</li> <li>⾮线性激活函
数，如ReLU；</li> <li>汇聚层，如最⼤汇聚层。</li></ol> <p>而⼀个VGG块与之类似，由⼀系列卷积层组成，后⾯再加上⽤于空间下采样的最⼤汇聚层。</p> <center><p><img src="/assets/img/vgg.d89ce0e4.svg" alt="img lost"></p> <p>从AlexNet到VGG，它们本质上都是块设计</p></center> <ul><li>VGG-11使⽤可复⽤的卷积块构造⽹络。不同的VGG模型可通过每个块中卷积层数量和输出通道数量的差异来定义。</li> <li>块的使⽤导致⽹络定义的⾮常简洁。使⽤块可以有效地设计复杂的⽹络。</li> <li>VGG论⽂尝试了各种架构，发现深层且窄的卷积（即3 × 3）⽐较浅层且宽的卷积更有效。</li></ul> <h2 id="nin"><a href="#nin" class="header-anchor">#</a> NiN</h2> <p>NiN重复使⽤由卷积层和1x1卷积层（⽤来代替全连接层）来构建深层⽹络。</p> <p>LeNet、AlexNet和VGG都有⼀个共同的设计模式：通过⼀系列的卷积层与汇聚层来提取空间结构特征；然后通过全连接层对特征的表征进⾏处理。AlexNet和VGG对LeNet的改进主要在于如何扩⼤和加深这两个模块。或者，可以想象在这个过程的早期使⽤全连接层。然而，如果使⽤了全连接层，可能会完全放弃表征的空间结构。⽹络中的⽹络（NiN）提供了⼀个⾮常简单的解决⽅案：在每个像素的通道上分别使⽤多层感知机。</p> <p>卷积层的输⼊和输出由四维张量组成，张量的每个轴分别对应样本、通道、⾼度和宽度。另外，全连接层的输⼊和输出通常是分别对应于样本和特征的⼆维张量。NiN的想法是在每个像素位置（针对每个⾼度和宽度）应⽤⼀个全连接层。如果我们将权重连接到每个空间位置，我们可以将其视为1x1卷积层，或作为在每个像素位置上独⽴作⽤的全连接层。从另⼀个⻆度看，即将空间维度中的每个像素视为单个样本，将通道维度视为不同特征（feature）。</p> <center><p><img src="/assets/img/nin.08b67554.svg" alt="img lost"></p> <p>对比 VGG 和 NiN 及它们的块之间主要架构差异</p></center> <ul><li>NiN使⽤由⼀个卷积层和多个1x1卷积层组成的块。该块可以在卷积神经⽹络中使⽤，以允许更多的每像素⾮线性。</li> <li>NiN去除了容易造成过拟合的全连接层，将它们替换为全局平均汇聚层（即在所有位置上进⾏求和）。该汇聚层通道数量为所需的输出数量（例如，Fashion-MNIST的输出为10）。</li> <li>移除全连接层可减少过拟合，同时显著减少NiN的参数。</li></ul> <h2 id="googlenet"><a href="#googlenet" class="header-anchor">#</a> GoogLeNet</h2> <p>使⽤并⾏连结的⽹络，通过不同窗口⼤小的卷积层和最⼤汇聚层来并⾏抽取信息
这篇论⽂的⼀个重点是解决了什么样⼤小的卷积核最合适的问题。毕竟，以前流⾏的⽹络使⽤小到1x1，⼤到11x11的卷积核。本⽂的⼀个观点是，有时使⽤不同⼤小的卷积核组合是有利的。</p> <p>Inception块由四条并⾏路径组成。前三条路径使⽤窗口⼤小为1x1、3 × 3和5 × 5的卷积层，
从不同空间⼤小中提取信息。中间的两条路径在输⼊上执⾏1x1卷积，以减少通道数，从而降低模型的复杂
性。第四条路径使⽤3 × 3最⼤汇聚层，然后使⽤1x1卷积层来改变通道数。这四条路径都使⽤合适的填充
来使输⼊与输出的⾼和宽⼀致，最后我们将每条线路的输出在通道维度上连结，并构成Inception块的输出。
在Inception块中，通常调整的超参数是每层输出通道数。</p> <center><p><img src="/assets/img/inception.2f8d4746.svg" alt="img lost"></p> <p>Inception块的架构</p></center>
为什么GoogLeNet这个⽹络如此有效呢？⾸先我们考虑⼀下滤波器（filter）的组合，它们可以⽤各种滤
波器尺⼨探索图像，这意味着不同⼤小的滤波器可以有效地识别不同范围的图像细节。同时，我们可以为不
同的滤波器分配不同数量的参数。
<center><p><img src="/assets/img/inception-full.9e66f990.svg" alt="img lost"></p> <p>GoogLeNet架构</p></center> <ul><li>Inception块相当于⼀个有4条路径的⼦⽹络。它通过不同窗口形状的卷积层和最⼤汇聚层来并⾏抽取信息，并使⽤1×1卷积层减少每像素级别上的通道维数从而降低模型复杂度。</li> <li>GoogLeNet将多个设计精细的Inception块与其他层（卷积层、全连接层）串联起来。其中Inception块的通道数分配之⽐是在ImageNet数据集上通过⼤量的实验得来的。</li> <li>GoogLeNet和它的后继者们⼀度是ImageNet上最有效的模型之⼀：它以较低的计算复杂度提供了类似的测试精度。</li></ul> <h2 id="批量规范化"><a href="#批量规范化" class="header-anchor">#</a> 批量规范化</h2> <p>可持续加速深层⽹络的收敛速度。再结合残差块，批量规范化使得研究⼈员能够训练100层以上的⽹络。</p> <p>为什么需要批量规范化层呢？</p> <ul><li>数据预处理的⽅式通常会对最终结果产⽣巨⼤影响。</li> <li>当我们训练时，中间层中的变量（例如，多层感知机中的仿射变换输出）可能具有更⼴的变化范围：不论是沿着从输⼊到输出的层，跨同⼀层中的单元，或是随着时间的推移，模型参数的随着训练更新变幻莫测。批量规范化的发明者⾮正式地假设，这些变量分布中的这种偏移可能会阻碍⽹络的收敛。直观地说，我们可能会猜想，如果⼀个层的可变值是另⼀层的100倍，这可能需要对学习率进⾏补偿调整。</li> <li>更深层的⽹络很复杂，容易过拟合。这意味着正则化变得更加重要。</li></ul> <p>其原理如下：在每次训练迭代中，我们⾸先规范化输⼊，即通过减去其均值并除以其标准差，其中两者均基于当前小批量处理。接下来，我们应⽤⽐例系数和⽐例偏移。正是由于这个基于批量统计的标准化，才有了批量规范化的名称。</p> <p>从形式上来说，⽤<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">x \in B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span>表⽰⼀个来⾃小批量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span>的输⼊，批量规范化BN根据以下表达式转换<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>：</p> <p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>N</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>γ</mi><mo>⊙</mo><mfrac><mrow><mi>x</mi><mo>−</mo><msub><mover accent="true"><mrow><mi>u</mi></mrow><mo>^</mo></mover><mrow><mi>β</mi></mrow></msub></mrow><mrow><msub><mover accent="true"><mrow><mi>σ</mi></mrow><mo>^</mo></mover><mrow><mi>β</mi></mrow></msub></mrow></mfrac><mo>+</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">BN(x)= \gamma \odot \frac{x-\hat{u}_{\beta}}{\hat{\sigma}_{\beta}}+\beta
</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:1.37144em;"></span><span class="strut bottom" style="height:2.343548em;vertical-align:-0.972108em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.05556em;">γ</span><span class="mbin">⊙</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.6859999999999999em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord"><span class="mord accent"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit" style="margin-right:0.03588em;">σ</span></span></span><span style="top:0em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="accent-body"><span>^</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05278em;">β</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit">x</span><span class="mbin">−</span><span class="mord"><span class="mord accent"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">u</span></span></span><span style="top:0em;margin-left:0.05556em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="accent-body"><span>^</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05278em;">β</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.05278em;">β</span></span></span></span></span></p> <p>由于单位⽅差（与其他⼀些魔法数）是⼀个任意的选择，因此我们通常包含拉伸参数（scale）<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05556em;">γ</span></span></span></span> 和偏移参数（shift）<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05278em;">β</span></span></span></span>，它们的形状与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>相同。请注意，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05556em;">γ</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05278em;">β</span></span></span></span>是需要与其他模型参数⼀起学习的参数。</p> <p>通常，我们将批量规范化层置于全连接层中的仿射变换和激活函数之间。设全连接层的输⼊为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>，权重参数和偏置参数分别为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">W</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">b</span></span></span></span>，激活函数为ϕ，批量规范化的运算符为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">BN</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span>。那么，使⽤批量规范化的全连接层的输出的计算详情如下：</p> <p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>=</mo><mi>ϕ</mi><mo>(</mo><mi>B</mi><mi>N</mi><mo>(</mo><mi>W</mi><mi>x</mi><mo>+</mo><mi>b</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">h=\phi(BN(Wx+b))
</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit">h</span><span class="mrel">=</span><span class="mord mathit">ϕ</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.13889em;">W</span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord mathit">b</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p> <p>同样，对于卷积层，我们可以在卷积层之后和⾮线性激活函数之前应⽤批量规范化。</p> <p>批量规范化在训练模式和预测模式下的⾏为通常不同。⾸先，将训练好的模型⽤于预
测时，我们不再需要样本均值中的噪声以及在微批次上估计每个小批次产⽣的样本⽅差了。其次，例如，我们可能需要使⽤我们的模型对逐个样本进⾏预测。⼀种常⽤的⽅法是通过移动平均估算整个训练数据集的样本均值和⽅差，并在预测时使⽤它们得到确定的输出。可⻅，和暂退法⼀样，批量规范化层在训练模式和预测模式下的计算结果也是不⼀样的。</p> <ul><li>在模型训练过程中，批量规范化利⽤小批量的均值和标准差，不断调整神经⽹络的中间输出，使整个神
经⽹络各层的中间输出值更加稳定。</li> <li>批量规范化在全连接层和卷积层的使⽤略有不同。</li> <li>批量规范化层和暂退层⼀样，在训练模式和预测模式下计算不同。</li> <li>批量规范化有许多有益的副作⽤，主要是正则化。另⼀⽅⾯，”减少内部协变量偏移“的原始动机似乎不是⼀个有效的解释。</li></ul> <h2 id="resnet"><a href="#resnet" class="header-anchor">#</a> ResNet</h2> <p>通过残差块构建跨层的数据通道，是计算机视觉中最流⾏的体系架构。</p> <p>⾸先，假设有⼀类特定的神经⽹络架构<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">F</span></span></span></span>，它包括学习速率和其他超参数设置。对于所有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>∈</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">f \in F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.13889em;">F</span></span></span></span>，存在⼀些参数集（例如权重和偏置），这些参数可以通过在合适的数据集上进⾏训练而获得。现在假设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">f^*</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord">∗</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>是我们真正想要找到的函数，如果是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mo>∗</mo></msup><mo>∈</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">f^* \in F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord">∗</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.13889em;">F</span></span></span></span>，那我们可以轻而易举的训练得到它，但通常我们不会那么幸运。相反，我们将尝试找到⼀个函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">f^*</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord">∗</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>，这是我们在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">F</span></span></span></span>中的最佳选择。</p> <p>那么，怎样得到更近似真正<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">f^*</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord">∗</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>的函数呢？唯⼀合理的可能性是，我们需要设计⼀个更强⼤的架构<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>F</mi><mi mathvariant="normal">′</mi></msup></mrow><annotation encoding="application/x-tex">F^\prime</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.751892em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">′</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>。换句话说，我们预计<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>f</mi><mrow><msup><mi>F</mi><mi mathvariant="normal">′</mi></msup></mrow><mo>∗</mo></msubsup></mrow><annotation encoding="application/x-tex">f^*_{F^\prime}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.947216em;vertical-align:-0.252776em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="vlist"><span style="top:0.252776em;margin-left:-0.10764em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord">∗</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>⽐<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>f</mi><mi>F</mi><mo>∗</mo></msubsup></mrow><annotation encoding="application/x-tex">f^*_F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.945467em;vertical-align:-0.251027em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="vlist"><span style="top:0.251027em;margin-left:-0.10764em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">F</span></span></span><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord">∗</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>“更近似”。然而，如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>⊊</mo><msup><mi>F</mi><mi mathvariant="normal">′</mi></msup></mrow><annotation encoding="application/x-tex">F \subsetneq F^\prime</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.887862em;vertical-align:-0.13597em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mrel amsrm">⊊</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">′</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>，则⽆法保证新的体系“更近似”。事实上，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>f</mi><mrow><msup><mi>F</mi><mi mathvariant="normal">′</mi></msup></mrow><mo>∗</mo></msubsup></mrow><annotation encoding="application/x-tex">f^*_{F^\prime}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.947216em;vertical-align:-0.252776em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="vlist"><span style="top:0.252776em;margin-left:-0.10764em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord">∗</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>可能更糟：如下图所⽰，对于⾮嵌套函数（non-nested function）类，较复杂的函数类并不总是向“真”函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">f^*</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord">∗</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>靠拢（复杂度由<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>F</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">F_1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>向<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>F</mi><mn>6</mn></msub></mrow><annotation encoding="application/x-tex">F_6</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">6</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>递增）。在下图左边，虽然<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>F</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">F_3</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>⽐<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>F</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">F_1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>更接近<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">f^*</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord">∗</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>，但<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>F</mi><mn>6</mn></msub></mrow><annotation encoding="application/x-tex">F_6</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">6</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>却离的更远了。相反对于下图右侧的嵌套函数（nested function）类<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>F</mi><mn>1</mn></msub><mo>⊆</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>⊆</mo><msub><mi>F</mi><mn>6</mn></msub></mrow><annotation encoding="application/x-tex">F_1 \subseteq ... \subseteq F_6</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">⊆</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mrel">⊆</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">6</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>，我们可以避免上述问题。</p> <center><p><img src="/assets/img/functionclasses.035dcee8.svg" alt="img lost"></p></center> <p>对于⾮嵌套函数类，较复杂（由较⼤区域表⽰）的函数类不能保证更接近“真”函数（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">f^*</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord">∗</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>）。这种现象在嵌套函数类中不会发⽣。</p> <p>因此，只有当较复杂的函数类包含较小的函数类时，我们才能确保提⾼它们的性能。对于深度神经⽹络，如果我们能将新添加的层训练成恒等映射（identity function）<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">f(x) = x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit">x</span></span></span></span>，新模型和原模型将同样有效。同时，由于新模型可能得出更优的解来拟合训练数据集，因此添加层似乎更容易降低训练误差。</p> <p>残差⽹络的核⼼思想是：每个附加层都应该更容易
地包含原始函数作为其元素之⼀。</p> <p>假设我们的原始输⼊为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>，而希望学出的理想映射为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span>（作为下图上⽅激活函数的输⼊）。下图左图虚线框中的部分需要直接拟合出该映射<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span>，而右图虚线框中的部分则需要拟合出残差映射<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">f(x) - x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span><span class="mbin">−</span><span class="mord mathit">x</span></span></span></span>。残差映射在现实中往往更容易优化。以本节开头提到的恒等映射作为我们希望学出的理想映射<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span>，我们只需将下图中右图虚线框内上⽅的加权运算（如仿射）的权重和偏置参数设成0，那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span>即为恒等映射。实际中，当理想映射<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span>极接近于恒等映射时，残差映射也易于捕捉恒等映射的细微波动。</p> <center><p><img src="/assets/img/residual-block.08b51fdf.svg" alt="img lost"></p> <p>⼀个正常块（左图）和⼀个残差块（右图）</p></center> <p>这样的设计要求2个卷积层的输出与输⼊形状⼀样，从而使它们可以相加。如果想改变通道数，就需要引⼊⼀个额外的1x1卷积层来将输⼊变换成需要的形状后再做相加运算。</p> <center><p><img src="/assets/img/resnet-block.e62ab6d1.svg" alt="img lost"></p> <p>包含以及不包含1x1卷积层的残差块</p></center>
ResNet每个模块有4个卷积层（不包括恒等映射的1x1卷积层）。加上第⼀个7 × 7卷积层和最后⼀个全连接层，共有18层。因此，这种模型通常被称为ResNet-18。
<center><p><img src="/assets/img/resnet18.05041aea.svg" alt="img lost"></p> <p>ResNet-18 架构</p></center> <ul><li>学习嵌套函数（nested function）是训练神经⽹络的理想情况。在深层神经⽹络中，学习另⼀层作为恒等映射（identity function）较容易（尽管这是⼀个极端情况）。</li> <li>残差映射可以更容易地学习同⼀函数，例如将权重层中的参数近似为零。</li> <li>利⽤残差块（residual blocks）可以训练出⼀个有效的深层神经⽹络：输⼊可以通过层间的残余连接更快地向前传播。</li></ul> <h2 id="densenet"><a href="#densenet" class="header-anchor">#</a> DenseNet</h2> <p>计算成本很⾼，但给我们带来了更好的效果</p> <p>ResNet将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span>分解为两部分：⼀个简单的线性项和⼀个复杂的⾮线性项。那么再向前拓展⼀步，如果我们想将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span>拓展成超过两部分的信息呢？⼀种⽅案便是DenseNet。</p> <p>ResNet和DenseNet的关键区别在于，DenseNet输出是连接（⽤图中的[, ]表⽰）而不是如ResNet的简单相加。</p> <center><p><img src="/assets/img/densenet-block.c83a90b0.svg" alt="img lost"></p> <p>ResNet（左）与 DenseNet（右）在跨层连接上的主要区别：使⽤相加和使⽤连结</p></center>
稠密⽹络主要由2部分构成：稠密块（dense block）和过渡层（transition layer）。前者定义如何连接输⼊和输出，而后者则控制通道数量，使其不会太复杂。
<center><p><img src="/assets/img/densenet.3ad447fb.svg" alt="img lost"></p> <p>稠密连接</p></center> <ul><li><p>⼀个稠密块由多个卷积块组成，每个卷积块使⽤相同数量的输出通道。然而，在前向传播中，我们将每个卷积块的输⼊和输出在通道维上连结。</p></li> <li><p>由于每个稠密块都会带来通道数的增加，使⽤过多则会过于复杂化模型。而过渡层可以⽤来控制模型复杂度。它通过1x1卷积层来减小通道数，并使⽤步幅为2的平均汇聚层减半⾼和宽，从而进⼀步降低模型复杂度。</p></li> <li><p>在跨层连接上，不同于ResNet中将输⼊与输出相加，稠密连接⽹络（DenseNet）在通道维上连结输⼊
与输出。</p></li> <li><p>DenseNet的主要构建模块是稠密块和过渡层。</p></li> <li><p>在构建DenseNet时，我们需要通过添加过渡层来控制⽹络的维数，从而再次减少通道的数量。</p></li></ul> <blockquote><p>https://zh.d2l.ai/index.html《动手学深度学习》</p></blockquote></div> <footer><!----> <hr> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h2 active"><a href="#从全连接到卷积" title="从全连接到卷积">从全连接到卷积</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#卷积层" title="卷积层">卷积层</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#填充" title="填充">填充</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#多输入多输出通道" title="多输⼊多输出通道">多输⼊多输出通道</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#多输入通道" title="多输入通道">多输入通道</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#多输出通道" title="多输出通道">多输出通道</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1x1卷积层" title="1X1卷积层">1X1卷积层</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#汇聚层-pooling" title="汇聚层 Pooling">汇聚层 Pooling</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#lenet" title="LeNet">LeNet</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#alexnet" title="AlexNet">AlexNet</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#vgg" title="VGG">VGG</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#nin" title="NiN">NiN</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#googlenet" title="GoogLeNet">GoogLeNet</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#批量规范化" title="批量规范化">批量规范化</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#resnet" title="ResNet">ResNet</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#densenet" title="DenseNet">DenseNet</a></div></div></div></div> <footer class="footer" data-v-3d9deeb8><div class="footer-left-wrap" data-v-3d9deeb8><ul class="contact" data-v-3d9deeb8><li class="contact-item" data-v-3d9deeb8><a href="https://github.com/liquanfeng" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-3d9deeb8><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github" data-v-3d9deeb8><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" data-v-3d9deeb8></path></svg>
          
        </a></li></ul></div> <div class="footer-right-wrap" data-v-3d9deeb8><ul class="copyright" data-v-3d9deeb8><li class="copyright-item" data-v-3d9deeb8>Copyright © 2020 liquanfeng</li><li class="copyright-item" data-v-3d9deeb8><a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-3d9deeb8>皖ICP备17014965号-1</a></li></ul></div></footer></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.7d39d6e2.js" defer></script><script src="/assets/js/8.a1e5b26c.js" defer></script><script src="/assets/js/3.ebaad69b.js" defer></script><script src="/assets/js/5.5b02d5fc.js" defer></script>
  </body>
</html>
